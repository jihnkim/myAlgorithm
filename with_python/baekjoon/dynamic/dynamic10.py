"""
10844

문제
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

## 팁
 각 자리수에서 맨 뒤에 올수 있는 숫자의 개수(0~9)

            0  1  2  3  4  5  6  7  8  9
자리수(1)   0  1  1  1  1  1  1  1  1  1
자리수(2)   1  1  2  2  2  2  2  2  2  1
자리수(3)   1  3  3  4  4  4  4  4  3  2

 

위의 규칙을 살펴보자. 자리수가 1일때, 각 숫자들이 맨뒷자리에 올 수 있는 개수는

 

1씩이다. 왜냐하면 자리수가 1이기 때문에. 자리수가 2일때를 보자.

 

맨 뒤에 0이 올 수 있는 경우의 수 - 10이 있다.(1개)

맨 뒤에 1이 올 수 있는 경우의 수 - 21이 있다.(1개)

맨 뒤에 2이 올 수 있는 경우의 수 - 12, 32이 있다.(2개)

 

이렇게 3자리수까지 구해보면 위와같은 표가 나올 수 있는데 규칙을 찾아보면,

해당 위치의 대각선 위 위치의 숫자들의 합인걸 알 수 있다.

당연한 소리다. 3이 맨 뒷자리에 가려면, 앞은 2나 4가 와야하기 때문.

0은 왼쪽대각선은 없으므로 오른쪽 대각선만. 9도 마찬가지로 오른쪽대각선은 없으므로 왼쪽 대각선만.

이렇게 점화식을 세워 코드를 작성해준다.


i = 자리수
j = 맨 뒤에 갈 수 있는 경우의 수.(0 ~ 9)
j = 0          dp[i][j] = dp[i - 1][1]

j = 9          dp[i][j] = dp[i - 1][8]

j = 2 ~ 8    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
"""

n = int(input())
dp = [[0 for i in range(10)] for j in range(101)]
for i in range(1, 10):
    dp[1][i] = 1
for i in range(2, n + 1):
    for j in range(10):
        if j == 0:
            dp[i][j] = dp[i - 1][1]
        elif j == 9:
            dp[i][j] = dp[i - 1][8]
        else:
            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
print(sum(dp[n]) % 1000000000)